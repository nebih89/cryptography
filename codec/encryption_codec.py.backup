import os
from cryptography.fernet import Fernet
import base64

class EncryptionCodec:
    def __init__(self):
        key = os.environ.get("TEMPORAL_ENCRYPTION_KEY")
        print(f"üîë DEBUG: Key from environment: {key is not None}")  # Add this line
        print(f"üîë DEBUG: Key length: {len(key) if key else 0}")      # Add this line
        
        if not key:
            raise ValueError("TEMPORAL_ENCRYPTION_KEY not set")
        self.fernet = Fernet(key.encode() if isinstance(key, str) else key)

    async def encode(self, payloads):
        """Encrypt each payload's 'data' field before storing in Temporal"""
        for p in payloads:
            data = p.get('data')
            if not data:
                continue
                
            try:
                # If data is base64 string (from Temporal), decode it first
                if isinstance(data, str):
                    try:
                        # Try to decode as base64 first
                        raw_data = base64.b64decode(data)
                    except:
                        # If not base64, encode the string
                        raw_data = data.encode()
                else:
                    raw_data = data
                
                # Encrypt the raw data
                encrypted = self.fernet.encrypt(raw_data)
                
                # Base64 encode for JSON serialization
                p['data'] = base64.b64encode(encrypted).decode()
                
                # Set encoding metadata
                if 'metadata' not in p or not isinstance(p['metadata'], dict):
                    p['metadata'] = {}
                p['metadata']['encoding'] = 'binary/encrypted'
                
            except Exception as e:
                print(f"Failed to encrypt payload: {e}")
                # Leave payload as-is if encryption fails
                
        return payloads

    async def decode(self, payloads):
        """Decrypt each payload's 'data' field when reading from Temporal"""
        print(f"üîì Decoding {len(payloads)} payloads")
        
        for p in payloads:
            print(f"Processing payload: {p}")
            
            # Check if this payload was encrypted by us
            metadata = p.get('metadata', {})
            print(f"Metadata: {metadata}")
            
            if metadata.get('encoding') != 'binary/encrypted':
                print("Skipping non-encrypted payload")
                continue  # Skip non-encrypted payloads
                
            data = p.get('data')
            if not data:
                print("No data found in payload")
                continue
                
            try:
                print(f"Encrypted data (first 50 chars): {data[:50]}...")
                
                # Data comes as base64 string, decode it first
                encrypted_data = base64.b64decode(data)
                print(f"Base64 decoded length: {len(encrypted_data)}")
                
                # Decrypt it
                decrypted_data = self.fernet.decrypt(encrypted_data)
                print(f"Decrypted data: {decrypted_data}")
                
                # Put back as base64 encoded string (Temporal expects this format)
                p['data'] = base64.b64encode(decrypted_data).decode()
                print(f"Final data: {p['data']}")
                
                # Clean up metadata
                if 'encoding' in p['metadata']:
                    del p['metadata']['encoding']
                    
                print("‚úÖ Successfully decrypted payload")
                    
            except Exception as e:
                print(f"‚ùå Failed to decrypt payload: {e}")
                import traceback
                traceback.print_exc()
                # Leave payload as-is if decryption fails
                
        return payloads